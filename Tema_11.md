# Тема 11. Итераторы и генераторы
Отчет по Теме #11 выполнил:
- Зуб Никита Валерьевич
- ИВТ-22-1

| Задание | Лаб_раб | Сам_раб |
| - | - | - |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + |   |
| Задание 4 | + |   |
| Задание 5 | + |   |


# Лабараторные работы 
   ## Лабараторная работа 1

  ```python
nums = [0, 1, 2, 3, 4, 5]
for item in nums:
    print(item)

```
  ### Результат
  
![image](https://github.com/user-attachments/assets/25f7a29d-8cfe-4717-8b74-cab6b5f2b5fd)


## Лабараторная работа 2

 ```python
class CountDown:
    def __init__(self, start):
        self.count = start + 1

    def __iter__(self):
        return self

    def __next__(self):
        self.count -= 1
        if self.count < 0:
            raise StopIteration
        return self.count


if __name__ == '__main__':
    counter = CountDown(5)
    for i in counter:
        print(i)

```

### Результат

![image](https://github.com/user-attachments/assets/ed936b77-90fc-4713-86c6-08a18caa88b4)


## Лабараторная работа 3

 ```python
a = [i ** 2 for i in range(1, 5)]

print("a - ", a)
for i in a:
    print(i)

print("iter(a) - ", iter(a))
for i in a:
    print(i)

```
### Результат

![image](https://github.com/user-attachments/assets/569ef775-fe50-406d-add1-cdc3aaa736f3)


## Лабараторная работа 4

 ```python
b = (i ** 2 for i in range(1, 5))
print(b)
for i in b:
    print(i)
print("second")


for i in b:
    print(i)

```
### Результат

![image](https://github.com/user-attachments/assets/fab677a1-7451-430b-932e-4b97d3c13f8c)


## Лабараторная работа 5

 ```python
def countdown(count):
    while count >= 0:
        yield count
        count -= 1


if __name__ == '__main__':
    counter = countdown(5)
    for i in counter:
        print(i)

```
### Результат

![image](https://github.com/user-attachments/assets/39dc71cc-f9db-48c1-a7f7-2cde4c96412e)




# Самостоятельные работы

## Самостоятельная работа №1

  ```python
def fib(n):
    f_n, f_n1 = 1, 1
    for i in range(n):
        yield f_n
        f_n, f_n1 = f_n1, f_n1 + f_n


n = 321
f_list = list(fib(n))
print(f_list[-1])

```

### Результат

![image](https://github.com/user-attachments/assets/856e076f-0125-4d08-b067-0a622f7025e7)


## Краткий вывод:
Программа принимает на вход номер числа Фибоначчи и выводит соответствующее значение на экран. Вместо использования оператора return, она применяет оператор yield, что преобразует функцию в генератор и значительно снижает затраты ресурсов.
 
## Самостоятельная работа №2

 ```python
def fib(n):
    f_n, f_n1 = 1, 1
    with open("fib.txt", "w") as file:
        for i in range(n):
            file.write(f"{f_n}\n")
            yield f_n
            f_n, f_n1 = f_n1, f_n1 + f_n


n = 321
f_list = list(fib(n))
print(f_list[-1])

```

### Результат

![image](https://github.com/user-attachments/assets/02666003-0481-4af8-bf1d-0d920aa43b05)



## Краткий вывод:
Программа функционирует по аналогичному принципу, как в первом задании, с одним уточнением: полученные числа Фибоначчи сохраняются в файл построчно. Функция по-прежнему принимает на вход номер искомого числа, но теперь результат, возвращаемый функцией, нужно преобразовать с помощью list() и затем вывести на консоль.


# Общий вывод 
Итераторы и генераторы языка программирования Python играют ключевую роль в обработке последовательностей данных. Изучив их функциональность, можно сделать следующие выводы:

  1. Итерации по данным:
  Python предоставляет эффективные средства для итерации по последовательностям данных. Итераторы позволяют поочередно получать элементы, что упрощает обработку больших объемов информации.
  
  2. Генераторы для создания последовательностей:
  Генераторы представляют собой мощный инструмент для создания последовательностей данных на лету. Они позволяют генерировать значения по мере необходимости, что особенно полезно при работе с большими или бесконечными данными.
  
  3. Операции с итерируемыми объектами:
  Python предоставляет обширный набор функций для работы с итерируемыми объектами, такими как списки, кортежи и строки. Это включает в себя функции, такие как map(), filter(), и sorted(), которые позволяют эффективно обрабатывать и изменять данные.
  
  4. Гибкость при работе с данными:
  Итераторы и генераторы обеспечивают гибкость при обработке данных различных типов. Возможность создания собственных итераторов и генераторов позволяет легко адаптировать их под конкретные потребности задачи.
  
  5. Эффективность использования памяти:
  Генераторы отличаются от списков тем, что они не хранят все значения в памяти сразу. Это позволяет экономить ресурсы и обрабатывать данные по мере необходимости.

Итераторы и генераторы в Python предоставляют эффективные средства для обработки данных в различных сценариях, от простых задач до сложных алгоритмов. Понимание их работы является важным элементом в арсенале разработчика для эффективной работы с последовательностями.
